<?php // -*- mode: php; coding: euc-japan -*-
include_once $_SERVER['DOCUMENT_ROOT'].'/lib/common.php';

$_lib_list_of_blah_msgs = array
(
 'First' => '最初へ',
 'Prev' => '前へ',
 'Next' => '次へ',
 'Last' => '最後へ',
);

////////////////////////////////////////////////////////////////
// A superclass to draw a list of things with paging control.
// A subclass must implement the following methods; some of them
// have a default implementation:
//
// * base_fetch_stmt()
//   Returns a string which is the beginning of a SELECT statement,
//   up to the condition of the WHERE clause.  If you want to draw everything,
//   end it with something like "WHERE (NULL IS NULL)".
//
// * row_paging_keys()
//   Returns an array of the keys to uniquely identify rows.  The rows
//   that sort equal according to order_by() are sorted using these keys
//   while paging.  The array is used as the array key to fetch the values
//   of paging keys from the return value of the SELECT statement built
//   from base_fetch_stmt().  This defaults to array('ObjectID').
//
// * row_paging_aliases()
//   Returns essentially the same information as row_paging_keys() but
//   in a syntax appropriate to use in the WHERE clause and ORDER BY
//   clause in the SELECT statment built from base_fetch_stmt().
//
//   The values returned from row_paging_aliases() may need to be different
//   from row_paging_keys() when the SELECT statement uses aliases.
//   For example, in a query:
//      SELECT S."ObjectID" as so, E."ObjectID" as eo, ...
//      FROM (SELECT ... UNION SELECT ...) as S, E
//      WHERE ...
//      ORDER BY ...
//   row_paging_keys() would be array('so', 'eo') and row_paging_aliases()
//   would be array('S."ObjectID"', 'E."ObjectID"').
//
//   Also notice in the above example that the values in row_paging_keys()
//   must have necessary SQL quote for column names.
//
//   The default implementation returns the values in row_paging_keys()
//   quoted for SQL using mx_db_sql_quote().
//
// * row_paging_orders()
//   Returns an array of true/false to tell if the data is sorted in the
//   forward order (i.e. without "DESC") or reverse order (i.e. with "DESC")
//   for each item in the row_paging_keys()/row_paging_aliases().
//   To sort everything in forward order you may return NULL.
//
// * draw_list_body()
//   calls draw_list_head() and draw_list_row(). los.php hooks this function
//   and added multi-column tables functionality.
//
// * draw_list_head()
//   Prints the heading rows in an HTML table, i.e. a list of
//   properly nested <tr>...</tr>.
//
// * draw_list_row(&$row, $ix, $total)
//   An assoc array returned from the SELECT statement built from
//   base_fetch_stmt is passed in $row, and $ix indicates the index
//   of this row in the resulting HTML table.  Prints the row's data
//   in an HTML table, i.e. a list of properly nested <tr>...</tr>.
//   $ix is useful to implement even/odd row coloring.
//
// * draw_no_data_message()
//   Print a message that says there is no data available.
//
// Note that you can draw an HTML table that uses more than one <tr>..</tr>
// pair to represent a row from the table with this class.
//
// The table generated by this class is of CSS class "listofstuff".
//
class list_of_blah {

  var $prefix;
  var $context;
  var $selection;
  var $page_base;
  var $page_direction;
  var $selection_changed;
  var $row_per_page;
  // PostgreSQL sorts NULL the last.
  var $null_sorts_later_than_everything_else = 1;

  var $default_row_per_page = 20;
  var $scrollable_height;
  var $debug = NULL;
  var $count_total_rows = NULL;

  // This can be 'U' (going upwards), 'D' (going downwards),
  // or 'DI' (going downwards, inclusive).
  var $default_page_direction = 'DI';

  function list_of_blah($prefix) {

    global $_lib_list_of_blah_msgs;

    $this->prefix = $prefix;
    $this->context = NULL;
    $this->selection = NULL;
    $this->selection_changed = NULL;
    $this->row_per_page = $this->default_row_per_page;
    $this->page_base = NULL;
    $this->page_direction = $this->default_page_direction;
    $this->paging_keys = array('ObjectID');
    $this->scrollable_height = NULL;
    $this->fetched_data = NULL;
    $this->more_data = -1;
    $this->paging_keys_namemap = array();

    $this->ui_msgs = $_lib_list_of_blah_msgs;

    $this->populate_from_request();
  }

  function populate_from_request() {

    $prefix = $this->prefix;
    $plen = strlen($prefix);

    if (array_key_exists($prefix . 'context', $_REQUEST))
      $this->context = $_REQUEST[$prefix . 'context'];

    if (array_key_exists($prefix . 'id', $_REQUEST))
      $this->selection = $_REQUEST[$prefix . 'id'];
    if (array_key_exists($prefix . 'id-select', $_REQUEST)) {
      $this->selection = $_REQUEST[$prefix . 'id-select'];
      $this->selection_changed = 1;
    }

    if (array_key_exists($prefix . 'page-next', $_REQUEST)) {
      $this->page_base = mx_form_unescape_key($_REQUEST[$prefix . 'page-1']);
      $this->page_direction = 'D';
    }
    elseif (array_key_exists($prefix . 'page-prev', $_REQUEST)) {
      $this->page_base = mx_form_unescape_key($_REQUEST[$prefix . 'page-0']);
      $this->page_direction = 'U';
    }
    elseif (array_key_exists($prefix . 'page-first', $_REQUEST)) {
      $this->page_base = NULL;
      $this->page_direction = 'D';
    }
    elseif (array_key_exists($prefix . 'page-last', $_REQUEST)) {
      $this->page_base = NULL;
      $this->page_direction = 'U';
    }
    else {
      if (array_key_exists($prefix . 'page-used-base', $_REQUEST))
	$this->page_base =
	  mx_form_unescape_key($_REQUEST[$prefix . 'page-used-base']);
      else
	$this->page_base = NULL;
      if (array_key_exists($prefix . 'page-used-direction', $_REQUEST))
	$this->page_direction = $_REQUEST[$prefix . 'page-used-direction'];
      else
	; // Default is left to the constructor.
    }
  }

  function reset($context) {

    $this->context = $context;
    $this->selection = NULL;
    $this->page_base = NULL;
    $this->page_direction = $this->default_page_direction;
    $this->selection_changed = 1;
    $this->_pk_aliases = NULL;
  }

  function chosen() {
    return $this->selection;
  }

  function changed() {
    return $this->selection_changed;
  }

  // subclasses may override this.
  function row_paging_keys() {
    return $this->paging_keys;
  }

  function compare_column_val($colname, $valconst) {
    $colname = mx_db_sql_quote_name($colname);
    if (is_null($valconst)) {
      return "$colname IS NULL";
    }
    return "$colname = " . mx_db_sql_quote($valconst);
  }

  // subclasses may override this.
  function row_paging_aliases() {
    // The fact we are called tells us that the subclass simply
    // uses row_paging_keys() for this purpose.
    if (is_null($this->_pk_aliases)) {
      $a = array();
      foreach ($this->row_paging_keys() as $pk) {
	$a[] = mx_db_sql_quote_name($pk);
      }
      $this->_pk_aliases =& $a;
    }
    return $this->_pk_aliases;
  }

  // subclasses may override this.
  function row_paging_orders() {
    return NULL;
  }

  ////////////////////////////////////////////////////////////////
  // Builds an SQL expression to compare row with the base paging key.
  //
  // pk_alias  : array of paging key names (input for WHERE clause)
  // pk_order  : array of paging key order (0 for forward, 1 for DESC)
  // pk_data   : array of data for the base paging key
  // direction : 'DI' down-inclusive, 'D' down, 'U' up
  // len       : length of pk_alias
  // ix        : recursion depth - which key are we looking at

  function key_compare_exp(&$pk_alias, &$pk_order, &$pk_data,
			   $direction, $len, $ix) {

    if ($this->debug && $ix == 0) {
      print "<!-- KCX\n";
      var_dump($pk_alias);
      var_dump($pk_order);
      var_dump($direction);
      print "-->\n";
    }

    $null_sorts_later_than_everything_else =
      $this->null_sorts_later_than_everything_else;
    $qn = $pk_alias[$ix];
    $qv = mx_db_sql_quote($pk_data[$ix]);
    $o = $pk_order[$ix];

    if ($qv == 'NULL') {
      // The base paging key is NULL.
      $nveq = "($qn is NULL)";
      if ($direction == 'DI') {
	if ($o) {
	  // We are looking for rows that sort equal or before NULL.
	  if ($null_sorts_later_than_everything_else)
	    $exp = "(NULL is NULL)";
	  else
	    $exp = "($qn is NULL)";
	}
	else {
	  // We are looking for rows that sort equal or after NULL.
	  if ($null_sorts_later_than_everything_else)
	    // Only null can sort equal or after null
	    $exp = "($qn is NULL)";
	  else
	    // NULL sorts earlier than everything else, so everything
	    // is eligible.
	    $exp = "(NULL is NULL)";
	}
      }
      else {
	if (($direction == 'D' && $o) || ($direction == 'U' && !$o)) {
	  // We are looking for rows that sort before NULL.
	  if ($null_sorts_later_than_everything_else)
	    // every non-NULL is eligible.
	    $exp = "($qn is not NULL)";
	  else
	    $exp = "(NULL is not NULL)";
	}
	else {
	  // We are looking for rows that sort after NULL.
	  if ($null_sorts_later_than_everything_else)
	    // Nothing is eligible, since nothing comes after NULL.
	    $exp = "(NULL is not NULL)";
	  else
	    // Non-NULL are all eligible.
	    $exp = "($qn is not NULL)";
	}
      }
    }
    else {
      // The base paging key is not NULL.
      $nveq = "($qn = $qv)";
      if ($direction == 'DI') {
	if ($o) {
	  // We are looking for rows that sort equal or before QV.
	  if ($null_sorts_later_than_everything_else)
	    $exp = "($qn <= $qv)";
	  else
	    $exp = "($qn <= $qv or $qn is NULL)";
	}
	else {
	  // We are looking for rows that sort equal or after QV.
	  if ($null_sorts_later_than_everything_else)
	    $exp = "($qv <= $qn or $qn is NULL)";
	  else
	    $exp = "($qv <= $qn)";
	}
      }
      else {
	if (($direction == 'D' && $o) || ($direction == 'U' && !$o)) {
	  // We are looking for rows that sort before QV.
	  if ($null_sorts_later_than_everything_else)
	    $exp = "($qn < $qv)";
	  else
	    $exp = "($qn < $qv or $qn is NULL)";
	}
	else {
	  // We are looking for rows that sort after QV.
	  if ($null_sorts_later_than_everything_else)
	    $exp = "($qv < $qn or $qn is NULL)";
	  else
	    $exp = "($qv < $qn)";
	}
      }
    }
    if ($ix + 1 < $len) {
      $tail = $this->key_compare_exp(&$pk_alias, &$pk_order, &$pk_data,
				     $direction, $len, $ix+1);
      $exp = "( $exp or ( $nveq and ( $tail ) ) )";
    }
    elseif ($direction == 'DI')
      $exp = "( $exp or $nveq )";
    else
      ;

    return $exp;
  }

  function draw_list_body($data){

      print "<thead>\n";

      $this->draw_list_head();

      print "</thead>\n";
      print "<tbody>\n";

      $total = count($data);
      for ($ix = 0; $ix < $total; $ix++)
	$this->draw_list_row($data[$ix], $ix, $total);

      print "</tbody>\n";
  }

  function build_order_by($pk_alias, $pk_order) {
    $order_by = array();
    for ($ix = 0; $ix < count($pk_alias); $ix++) {
      if (($this->page_direction == 'U' && !$pk_order[$ix]) ||
	  ($this->page_direction != 'U' && $pk_order[$ix]))
	$order_by[] = $pk_alias[$ix] . ' DESC';
      else
	$order_by[] = $pk_alias[$ix];
    }
    return "\nORDER BY\n " . implode(",\n ", $order_by);
  }

  function fetch_data() {

    $pk_alias = $this->row_paging_aliases();
    $pk_order = $this->row_paging_orders();
    if (is_null($pk_order)) {
      $pk_order = array();
      foreach ($pk_alias as $a) {
	$pk_order[] = 0;
      }
    }

    $db = mx_db_connect();
    $stmt = $this->base_fetch_stmt();

    $order_by = $this->build_order_by($pk_alias, $pk_order);

    $count_total_stmt = $stmt;
    if (! is_null($this->page_base)) {
      $base = $this->page_base[0];
      $stmt .= "\nAND " . $this->key_compare_exp($pk_alias, $pk_order,
						 $this->page_base,
						 $this->page_direction,
						 count($pk_alias), 0);
    }
    $stmt .= $order_by;

    $count_total_stmt .= $order_by;
    $count_remainder_stmt = $stmt;

    if (0 < $this->row_per_page) {
      $stmt .= "\nLIMIT " . ($this->row_per_page + 1);
    }

    if ($this->debug) {
      print "<!--\n";
      print "Direction: " . $this->page_direction . "\n";
      print "Base: ";
      var_dump($this->page_base);
      print "-->\n<!--\n" . $stmt . ";\n-->\n";
    }

    $sth = pg_query($db, $stmt);
    if (!$sth) {
	    print "<!-- $stmt -->\n";
	    $this->fetched_data = array();
    } else {
	    $this->fetched_data = pg_fetch_all($sth);
    }
    $this->more_data = 0;

    if (is_array($this->fetched_data)) {
      if (0 < $this->row_per_page &&
	  $this->row_per_page < count($this->fetched_data)) {
	$this->more_data = 1;
	array_splice($this->fetched_data, $this->row_per_page);
      }
      if ($this->page_direction == 'U') {
	$this->fetched_data = array_reverse($this->fetched_data);
      }
    } else {
      $this->fetched_data = array();
    }

    if ($this->count_total_rows) {
	    $this->num_total_rows = 0;
	    $this->num_remaining_rows = 0;
	    if (($sth = pg_query($db, $count_total_stmt)) &&
		($d = pg_fetch_all($sth)) &&
		is_array($d))
		    $this->num_total_rows = count($d);
	    if (($sth = pg_query($db, $count_remainder_stmt)) &&
		($d = pg_fetch_all($sth)) &&
		is_array($d))
		    $this->num_remaining_rows = count($d);
    }
    $this->annotate_fetched_data();
  }

  function annotate_fetched_data() {
  }

  function fetch_window() {
	  if ($this->more_data < 0)
		  $this->fetch_data();
	  $more = $this->more_data;
	  $data = $this->fetched_data;
	  if (!is_array($data)) {
		  $this->more_data = 0;
		  $data = $this->fetched_data = array();
	  }
	  if (!count($data)) {
		  /*
		   * Do we really have nothing, or maybe somebody
		   * deleted everything after our key?  Swap the
		   * direction and re-scan from the end.
		   */
		  $this->page_direction =
			  ($this->page_direction == 'U') ? 'D' : 'U';
		  $this->page_base = NULL;
		  $this->fetch_data();
	  }
	  if (!$this->more_data && $this->page_direction == 'U') {
		  /*
		   * We were going back and ran out.  Try
		   * refetching from the beginning and see
		   * what happens.
		   */
		  $this->page_direction = 'D';
		  $this->page_base = NULL;
		  $this->fetch_data();
	  }
  }

  function draw_arrows($data, $more, $draw_only=0) {
      $page_0 = array();
      $page_1 = array();
      $last = count($data)-1;
      $pk_name = $this->row_paging_keys();
      for ($ix = 0; $ix < count($pk_name); $ix++) {
	      $name = $pk_name[$ix];
	      if (array_key_exists($name, $this->paging_keys_namemap))
		      $name = $this->paging_keys_namemap[$name];
	      $page_0[] = $data[0][$name];
	      $page_1[] = $data[$last][$name];
      }
      if ($this->debug) {
	print "<!--\n";
	print 'pk_name:'; var_dump($pk_name);
	print 'page_0:'; var_dump($page_0);
	print 'data[0]:'; var_dump($data[0]);
	print 'page_1:'; var_dump($page_1);
	print 'data[last]:'; var_dump($data[$last]);
	print 'pkn:'; var_dump($this->paging_keys_namemap);
	print "-->\n";
      }

      if(!$draw_only) {
        mx_formi_hidden($this->prefix . "page-0", mx_form_escape_key($page_0));
        mx_formi_hidden($this->prefix . "page-1", mx_form_escape_key($page_1));
      }

      // Can we go back?
      if ($this->page_direction == 'U' && ! $more)
	// Not if we are going backward and there is no more.
	;
      elseif ($this->page_direction != 'U' && is_null($this->page_base))
	// Not if we are at the beginning and going forward
	;
      else
	$navigate_prev = 1;

      // Can we go forward?
      if ($this->page_direction != 'U' && ! $more)
	// Not if we are going forward and there is no more.
	;
      elseif ($this->page_direction == 'U' && is_null($this->page_base))
	// Not if we are at the end and going backward
	;
      else
	$navigate_next = 1;

    if ($navigate_prev) {
      mx_formi_submit($this->prefix . "page-first", 'First',
		      mx_img_url('first.png'),
		      $this->ui_msgs['First']);
      mx_formi_submit($this->prefix . "page-prev", 'Prev',
		      mx_img_url('prev.png'),
		      $this->ui_msgs['Prev']);
    }

    if ($navigate_next) {
      mx_formi_submit($this->prefix . "page-next", 'Next',
		      mx_img_url('next.png'),
		      $this->ui_msgs['Next']);
      mx_formi_submit($this->prefix . "page-last", 'Last',
		      mx_img_url('last.png'),
		      $this->ui_msgs['Last']);
    }

  }

  function draw() {

    global $_mx_show_pager_at_top;
    global $_lib_list_of_blah_msgs;

    $this->fetch_window();
    $more = $this->more_data;
    $data = $this->fetched_data;
    $navigate_prev = $navigate_next = NULL;

    if (count($data)) {
      $style = '';
      if($this->scrollable_height)
        $style = sprintf(' style="overflow-y: scroll; height: %s;"', 
			 $this->scrollable_height);
      // setting style to TBODY results in undesired horizontal scrollbar.
      // wrap the table with div and apply style to the div for now.
      // header row scrolls together with this solution  :(
      if ($_mx_show_pager_at_top)
        $this->draw_arrows($data, $more, 1);
      print "<div".$style.">\n";
      print "<table class=\"listofstuff\">\n";
      $this->draw_list_body($data);
      print "</table>\n";
      print "</div>\n";
      $this->draw_arrows($data, $more);
    }
    else {
      $this->draw_no_data_message();
    }

    if ($this->count_total_rows && $this->num_total_rows) {
	    if ($this->page_direction == 'U') {
		    /* going reverse */
		    $nth = $this->num_remaining_rows - count($data) + 1;
	    } else {
		    $nth = ($this->num_total_rows -
			    $this->num_remaining_rows + 1);
	    }

	    if ($this->count_total_rows == 1)
		    $fmt = "%d/%d";
	    else
		    $fmt = $this->count_total_rows;
	    printf($fmt, $nth, $this->num_total_rows);
    }

    mx_formi_hidden($this->prefix . 'id', $this->selection);
    mx_formi_hidden($this->prefix . 'context', $this->context);
    mx_formi_hidden($this->prefix . 'page-used-base',
		    mx_form_escape_key($this->page_base));
    mx_formi_hidden($this->prefix . 'page-used-direction',
		    $this->page_direction);
  }
}
?>
